package problems20to29;

import java.math.BigInteger;
import personal_library.MathFunctions;

//Question -----------------------------------------------------------------------------------------------------------------------
//	A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:
//	
//	1/2	= 	0.5
//	1/3	= 	0.(3)
//	1/4	= 	0.25
//	1/5	= 	0.2
//	1/6	= 	0.1(6)
//	1/7	= 	0.(142857)
//	1/8	= 	0.125
//	1/9	= 	0.(1)
//	1/10	= 	0.1
//	Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.
//	
//	Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.
//---------- -----------------------------------------------------------------------------------------------------------------------
// Solution correct 


// General Idea: A recurring cycle x long can be represented as (one-sequence-of-recurrence / nines-recurrence-long)
// Eg. 0.11111 = 1 / 9
//     0.121212 = 12 / 99
//
// So the idea is to take the fraction (eg. 1 / 7) and see how many 9s you need before nines-recurrence-long % denominator == 0
// that way you get the length of the recurrence! So for the example:
//   999999 % 7 == 0 and that's how you get --> ( 1 / 7 ) = ( 142857 / 999999 )
//
// There are two things to be weary of with this method:
//	 	1. You must make sure that the fraction does indeed have a recurrence to begin with
//      2. You must be careful with situations like 1/6 where the recurrence does not start immediately (0.1666666)
//
// Problem 1:
// 		As I go through the denominator and attempt to put it over a series of 9s I also attempt to see if 10^n % denominator == 0
//		If I find some n where 10^n % denominator == 0 then this number has no recurrence. 
//			eg. 1 / 4 has no recurrence (0.25) and can be seen with this technique as 100 % 4 == 0 
//
// Problem 2: 
//		This is a more difficult problem to deal with, and one must think about how a situation arises where the recurrence does not
//		begin at the start but rather after some x digits. For example, 1 / 6 has a recurrence 1-long but it starts at the second digit (0.16666)
// 		After some thought, you realize that 1 / 6 = (1 / 3) * (1 / 2) and that the recurrence is generated by the (1 / 3) and that the (1 / 2)
// 		simply shifts the recurrence resulting in it starting at the second digit. This means that any denominator that is not a prime that has a 
//  	recurrence can be written as the prime that caused the recurrence * non-primes. Hence, the only denominators that we must look at are
//		prime! This makes the search much faster as well as getting rid of situations where the recurrence does not begin at the first digit!
public class Problem26 {

	private static int greatestDenom;				// the denominator that currently produces the greatest recurrence-length 
	private static int currrentDenom; 				// current denominator between 1 and a 1000
	private static boolean notFound;				// clean loop-control variable
	private static int currentGreatestLength; 		// recording the current greatest length 
 
	public static void main(String[] args) {
		currentGreatestLength = 0; 				

		// Go through all the prime denominators from 1-1000 using the technique specified above in *GeneralIdea*
		for(currrentDenom = 1; currrentDenom < 1000; currrentDenom++) {
			if(MathFunctions.checkPrime(currrentDenom)) {
				notFound = true; 
				int length = 0;						// To record the length of the nines/tens (eg length = 3 results in 999 or 1000) 
				while(notFound) {	
					checkOverNines(length);			// seeing if it has a recurrence 
					checkOverTens(length);			// seeing if it has no recurrence 
				    length++;
				}
			}
		}
		// Print out the answer
        System.out.println(greatestDenom);
	}

	// Private Function
	// refer to *general idea* for purpose
	private static void checkOverTens(int n) {
		
		// get 10^(n + 1) 
		BigInteger tens = BigInteger.TEN;
		for(int b = 0; b < n; b++) {
			tens = tens.multiply(BigInteger.TEN);
		}
		
		// check if 10^(n+1) % currentDenom == 0 
		if(tens.remainder(BigInteger.valueOf(currrentDenom)).equals(BigInteger.ZERO)) {
			notFound = false; 						// this number has no recurrence 
		}	
	}

	// Private Function
	// refer to *general idea* for purpose
	private static void checkOverNines(int a) {

		// get 999... where there are a+1 nines 
		String ninesString = "9";
		for(int i = 0; i < a;i++) {
			ninesString = ninesString.concat("9");
		}
		BigInteger ninesBigInt = new BigInteger(ninesString);

		// if 999... % currentDenom == 0 then the number has a recurrence equal to the length of ninesBigInt
		if(ninesBigInt.remainder(BigInteger.valueOf(currrentDenom)).equals(BigInteger.ZERO)) {
			// check if this recurrence is bigger than the current biggest
			if(ninesString.length() > currentGreatestLength) {
				greatestDenom = currrentDenom; 
				currentGreatestLength = ninesString.length();
			}
			notFound = false; 
		}		
	}
}